<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Youngjoon Lee</title><link>https://oudwud.dev/</link><description>Recent content on Youngjoon Lee</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 04 May 2023 23:45:00 +0900</lastBuildDate><atom:link href="https://oudwud.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploring rust-libp2p</title><link>https://oudwud.dev/posts/2305042345-exploring-rust-libp2p/</link><pubDate>Thu, 04 May 2023 23:45:00 +0900</pubDate><guid>https://oudwud.dev/posts/2305042345-exploring-rust-libp2p/</guid><description>Connectivity Tests # In libp2p.io, the current state of Transport implementations in each programming language already written. But, Iâ€™ve seen there have been so many changes in rust-libp2p, as described in the rust-libp2p in 2022 blog post.
After reading the libp2p Connectivity document, I&amp;rsquo;ve tested if &amp;lsquo;dialing&amp;rsquo; works for each of the following scenarios using rust-libp2p v0.51.3.
Scenario Dialing Transports tested Standalone -&amp;gt; Standalone Successful TCP, WebSocket, WebRTC1) WASM browser -&amp;gt; Standalone Successful WebSocket2) WASM browser &amp;lt;- Standalone Failed3) WebSocket WASM browser -&amp;gt; WASM browser Failed3) WebSocket JS browser4) -&amp;gt; Standalone Successful WebRTC Private -&amp;gt; (Relay5)) -&amp;gt; Private Successful TCP Private6) -&amp;gt; (Relay5)) -&amp;gt; Private with Hole-punching Failed7) TCP 1) WebRTC example 2) vincev/wasm-p2p-chat based on vincev/libp2p-websys-transport that will be included in the rust-libp2p offically 3) Browser nodes cannot listen for incoming conns.</description></item><item><title>OSS Contribution: AstroNvim/astrocommunity</title><link>https://oudwud.dev/posts/2305021340-astronvim-contribution/</link><pubDate>Tue, 02 May 2023 13:40:00 +0900</pubDate><guid>https://oudwud.dev/posts/2305021340-astronvim-contribution/</guid><description>AstroNvim/astrocommunity: feat(git): add openingh #178</description></item><item><title>Why prevote in Tendermint</title><link>https://oudwud.dev/posts/2304182106-why-prevote-in-tendermint/</link><pubDate>Tue, 18 Apr 2023 21:06:00 +0900</pubDate><guid>https://oudwud.dev/posts/2304182106-why-prevote-in-tendermint/</guid><description>Tendermint Byzantine Fault Tolerance (hereafter BFT) consensus algorithm has two stages of voting before committing a block to the state, while Raft consensus algorithm (that doesn&amp;rsquo;t cover the Byzantine problem) has a single stage of preparation (aka. log replication) for committing a transaction. When I first met Tendermint, I was most curious why Tendermint has the two-stage voting (prevote-precommit).
In Ethan Buchman 2016, he mentioned as below:
In asynchronous environments with Byzantine validators, a single stage of voting, where each validator casts only one vote, is not sufficient to ensure safety.</description></item><item><title>What's happened, happened</title><link>https://oudwud.dev/posts/2303281600-whats-happened/</link><pubDate>Tue, 28 Mar 2023 16:00:00 +0900</pubDate><guid>https://oudwud.dev/posts/2303281600-whats-happened/</guid><description>It&amp;rsquo;s an expression of faith in the mechanics of the world. It&amp;rsquo;s not an excuse for doing nothing.</description></item><item><title>OSS Contribution: bls12-381</title><link>https://oudwud.dev/posts/2103301623-bls-contribution/</link><pubDate>Tue, 30 Mar 2021 16:23:00 +0900</pubDate><guid>https://oudwud.dev/posts/2103301623-bls-contribution/</guid><description>bls12-381: Support 32-bit architecture (#31)</description></item><item><title>Thought about Storage on Kubernetes</title><link>https://oudwud.dev/posts/2007061657-thought_about_storage_on_k8s/</link><pubDate>Mon, 06 Jul 2020 16:57:28 +0900</pubDate><guid>https://oudwud.dev/posts/2007061657-thought_about_storage_on_k8s/</guid><description>Kubernetes is revolutionizing the way applications are being developed and deployed. Now, developers can focus on implementing the application itself without worrying about the underlying infrastructure and some of distributed system concepts.
However, Kubernetes doesn&amp;rsquo;t support storing state, even though most of applications are stateful.
On Kubernetes, containers can being created and destroyed. They are dynamic. But, persistent storages cannot be dynamic as normal Pods.
Many SW teams have been using distributed storage solutions provided by cloud providers, such as AWS or GCP.</description></item><item><title>HyperLogLog</title><link>https://oudwud.dev/posts/2006281453-hyperloglog/</link><pubDate>Sun, 28 Jun 2020 14:53:42 +0900</pubDate><guid>https://oudwud.dev/posts/2006281453-hyperloglog/</guid><description>Given a stream of strings, let&amp;rsquo;s think how to count the number of distinct strings (Cardinality).
Using in-memory data structure # The simplest way might be using a in-memory data structure, such as HashSet. Whenever we read a string from the stream, we can add it to the HashSet. Finally, we can return the final size of HashSet.
But, this way needs O(n) of memory at most, if n is the number of strings in the stream.</description></item><item><title>My first open source contribution was just released.</title><link>https://oudwud.dev/posts/2006111140-argo-release/</link><pubDate>Thu, 11 Jun 2020 11:40:26 +0900</pubDate><guid>https://oudwud.dev/posts/2006111140-argo-release/</guid><description>My first open source contribution (bugfix) to Argo. It was just released as v2.9.0-rc1.</description></item></channel></rss>